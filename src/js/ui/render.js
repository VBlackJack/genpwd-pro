/*
 * Copyright 2025 Julien Bombled
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// src/js/ui/render.js - Results and cards rendering
import { getElement } from './dom.js';
import { copyToClipboard } from '../utils/secure-clipboard.js';
import { showToast } from '../utils/toast.js';
import { t } from '../utils/i18n.js';
import { compositionCounts, escapeHtml } from '../utils/helpers.js';
import { safeLog } from '../utils/logger.js';
import { sanitizeHTML } from '../utils/dom-sanitizer.js';
import { VaultBridge } from './vault-bridge.js';
import { SaveToVaultModal } from './save-to-vault-modal.js';
import { checkPasswordBreach, formatBreachCount, getBreachSeverity } from '../utils/breach-check.js';

const clickTimers = new WeakMap();
let eventController = new AbortController();

export function renderResults(results, mask) {
  const wrap = getElement('#results-list');
  if (!wrap) return;

  try {
    cleanupPasswordListeners();
    wrap.innerHTML = sanitizeHTML('');

    if (!Array.isArray(results) || results.length === 0) {
      wrap.innerHTML = sanitizeHTML(`
        <div class="empty-state">
          <div class="empty-icon">üîê</div>
          <p>${t('generator.emptyState') || 'No passwords generated yet'}</p>
          <button type="button" class="btn btn-accent empty-state-cta" id="empty-generate-btn">
            <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
              <path d="M12 3v3m0 12v3M4.22 4.22l2.12 2.12m11.32 11.32l2.12 2.12M3 12h3m12 0h3M4.22 19.78l2.12-2.12M18.36 6.34l2.12-2.12"/>
              <circle cx="12" cy="12" r="4"/>
            </svg>
            ${t('actions.generateNow') || 'Generate Now'}
          </button>
        </div>`);
      // Attach click handler for the CTA button
      document.getElementById('empty-generate-btn')?.addEventListener('click', () => {
        document.getElementById('btn-generate')?.click();
      });
      return;
    }

    // PERFORMANCE: Use DocumentFragment to batch DOM updates
    // This reduces reflows from O(n) to O(1) when rendering multiple passwords
    const fragment = document.createDocumentFragment();

    results.forEach((item, idx) => {
      const { value } = item;
      if (typeof value !== 'string') return;

      const card = createPasswordCard(item, idx + 1, mask);
      fragment.appendChild(card);
    });

    // Single DOM update instead of n updates
    wrap.appendChild(fragment);

    bindPasswordClickEvents();
  } catch (e) {
    safeLog(`renderResults error: ${e.message}`);
  }
}

function createPasswordCard(item, id, mask) {
  // Null guard for invalid items
  if (!item?.value || typeof item.value !== 'string') {
    const placeholder = document.createElement('div');
    placeholder.className = 'card card-error';
    placeholder.textContent = t('vault.generator.invalidData');
    return placeholder;
  }

  const { value, entropy, mode, dictionary } = item;
  const counts = compositionCounts(value);
  const total = value.length || 1;

  // Calculate segments for the composition bar
  const segU = Math.round(counts.U / total * 1000) / 10;
  const segL = Math.round(counts.L / total * 1000) / 10;
  const segD = Math.round(counts.D / total * 1000) / 10;
  const segS = Math.round(counts.S / total * 1000) / 10;

  // Dictionary information
  const dictInfo = mode === 'passphrase' && dictionary ?
    `${dictionary.charAt(0).toUpperCase() + dictionary.slice(1)}` :
    mode || 'unknown';

  // Vault save button (only visible in Electron)
  const vaultAvailable = VaultBridge.isAvailable();
  const saveToVaultBtn = vaultAvailable ? `
    <button class="action-btn save-to-vault-btn" type="button" data-password="${escapeHtml(value)}" title="${t('common.save')}" aria-label="${t('vault.actions.saveToVault')}">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
        <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
        <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
      </svg>
    </button>
  ` : '';

  const card = document.createElement('div');
  card.className = 'card';
  // Note: No sanitizeHTML here - all dynamic content is already escaped with escapeHtml()
  // The structure is static HTML generated by our code, not user input
  card.innerHTML = `
    <div class="card-sec card-header">
      <div class="id">#${id}</div>
      <span class="spacer"></span>
      <div class="stat"><span class="dot"></span><strong>${(entropy || 0).toFixed(1)}</strong>&nbsp;bits</div>
      <div class="len">${total} chars</div>
    </div>
    <div class="card-sec pwd ${mask ? 'masked' : ''}" data-index="${id-1}" data-password="${escapeHtml(value)}" title="${t('results.clickToCopyHint')}" role="button" tabindex="0" aria-label="${t('results.passwordAriaLabel', { id })}">
      <div class="value mono">${escapeHtml(value)}</div>
      <div class="actions">
        <button class="action-btn breach-check-btn" type="button" data-password="${escapeHtml(value)}" title="${t('breach.checkButton') || 'Check for breaches'}" aria-label="${t('breach.checkButton') || 'Check for breaches'}">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path>
          </svg>
        </button>
        ${saveToVaultBtn}
        <button class="action-btn copy-btn" type="button" title="${t('common.copy') || 'Copy'}" aria-label="${t('toast.copyPassword') || 'Copy password'}">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
            <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
          </svg>
        </button>
      </div>
      <div class="breach-status" role="status" hidden></div>
    </div>
    <div class="card-sec comp">
      <div class="comp-bar">
        ${segU > 0 ? `<div class="seg u" data-width="${segU}"></div>` : ''}
        ${segL > 0 ? `<div class="seg l" data-width="${segL}"></div>` : ''}
        ${segD > 0 ? `<div class="seg d" data-width="${segD}"></div>` : ''}
        ${segS > 0 ? `<div class="seg s" data-width="${segS}"></div>` : ''}
      </div>
      <div class="comp-legend">
        <span class="legend-item"><span class="legend-dot u"></span>${counts.U} ${t('results.composition.upper')}</span>
        <span class="legend-item"><span class="legend-dot l"></span>${counts.L} ${t('results.composition.lower')}</span>
        <span class="legend-item"><span class="legend-dot d"></span>${counts.D} ${t('results.composition.digits')}</span>
        <span class="legend-item"><span class="legend-dot s"></span>${counts.S} ${t('results.composition.special')}</span>
      </div>
    </div>
    <div class="card-sec info"><div>${t('results.composition.mode')}: ${dictInfo}</div><div>${t('results.composition.cliSafe')}: ‚úì</div></div>
  `;

  // Apply widths via CSS custom properties (CSP-compliant)
  const compBar = card.querySelector('.comp-bar');
  if (compBar) {
    const segments = compBar.querySelectorAll('.seg');
    segments.forEach(seg => {
      const width = seg.getAttribute('data-width');
      if (width) {
        seg.style.setProperty('--seg-width', `${width}%`);
      }
    });
  }

  return card;
}

function bindPasswordClickEvents() {
  const passwordElements = document.querySelectorAll('.pwd');

  passwordElements.forEach(el => {
    // Click on password area (not on buttons)
    el.addEventListener('click', async (e) => {
      // Don't trigger if clicking on buttons
      if (e.target.closest('.save-to-vault-btn') || e.target.closest('.copy-btn') || e.target.closest('.breach-check-btn')) {
        return;
      }

      e.preventDefault();

      const existingTimer = clickTimers.get(el);
      if (existingTimer) {
        clearTimeout(existingTimer);
        clickTimers.delete(el);

        // Double-click: toggle mask
        el.classList.toggle('masked');
        return;
      }

      // Single click: schedule copy
      const timer = setTimeout(async () => {
        try {
          clickTimers.delete(el);

          const password = el.getAttribute('data-password');
          if (password) {
            el.classList.add('copying');

            const success = await copyToClipboard(password);
            if (success) {
              showToast(t('toast.passwordCopied'), 'success');
              safeLog(`Copied: ${password.substring(0, 8)}...`);
            } else {
              showToast(t('toast.copyFailed'), 'error');
            }

            setTimeout(() => {
              el.classList.remove('copying');
            }, 600);
          }
        } catch (err) {
          safeLog('Copy to clipboard failed:', err);
          showToast(t('toast.copyFailed'), 'error');
        }
      }, 250);

      clickTimers.set(el, timer);
    }, { signal: eventController.signal });

    // Context menu (right-click)
    el.addEventListener('contextmenu', (e) => {
      e.preventDefault();
      const password = el.getAttribute('data-password');
      if (password) {
        showContextMenu(e, password);
      }
    }, { signal: eventController.signal });

    // Keyboard support for role="button" accessibility + list navigation
    el.addEventListener('keydown', async (e) => {
      if (e.key === 'Enter') {
        // Enter: copy password
        e.preventDefault();
        const password = el.getAttribute('data-password');
        if (password) {
          el.classList.add('copying');
          const success = await copyToClipboard(password);
          if (success) {
            showToast(t('toast.passwordCopied'), 'success');
          } else {
            showToast(t('toast.copyFailed'), 'error');
          }
          setTimeout(() => el.classList.remove('copying'), 600);
        }
      } else if (e.key === ' ') {
        // Space: toggle mask
        e.preventDefault();
        el.classList.toggle('masked');
      } else {
        // List navigation (Home/End/PageUp/PageDown/Arrow keys)
        const allCards = Array.from(document.querySelectorAll('.pwd'));
        const currentIndex = allCards.indexOf(el);
        const pageSize = 5; // Number of cards to skip with PageUp/PageDown
        let targetIndex = -1;

        switch (e.key) {
          case 'Home':
            e.preventDefault();
            targetIndex = 0;
            break;
          case 'End':
            e.preventDefault();
            targetIndex = allCards.length - 1;
            break;
          case 'PageUp':
            e.preventDefault();
            targetIndex = Math.max(0, currentIndex - pageSize);
            break;
          case 'PageDown':
            e.preventDefault();
            targetIndex = Math.min(allCards.length - 1, currentIndex + pageSize);
            break;
          case 'ArrowUp':
            e.preventDefault();
            targetIndex = Math.max(0, currentIndex - 1);
            break;
          case 'ArrowDown':
            e.preventDefault();
            targetIndex = Math.min(allCards.length - 1, currentIndex + 1);
            break;
        }

        if (targetIndex >= 0 && targetIndex !== currentIndex && allCards[targetIndex]) {
          allCards[targetIndex].focus();
          // Scroll into view smoothly (respects prefers-reduced-motion)
          allCards[targetIndex].scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
      }
    }, { signal: eventController.signal });
  });

  // Bind save-to-vault buttons
  bindSaveToVaultButtons();

  // Bind copy buttons
  bindCopyButtons();

  // Bind breach check buttons
  bindBreachCheckButtons();

  safeLog(`Bound click events to ${passwordElements.length} password cards`);
}

/**
 * Bind save-to-vault button click events
 */
function bindSaveToVaultButtons() {
  const saveButtons = document.querySelectorAll('.save-to-vault-btn');

  saveButtons.forEach(btn => {
    btn.addEventListener('click', async (e) => {
      e.preventDefault();
      e.stopPropagation();

      const password = btn.getAttribute('data-password');
      if (password) {
        await SaveToVaultModal.open(password);
      }
    }, { signal: eventController.signal });
  });
}

/**
 * Bind copy button click events
 */
function bindCopyButtons() {
  const copyButtons = document.querySelectorAll('.copy-btn');

  copyButtons.forEach(btn => {
    btn.addEventListener('click', async (e) => {
      e.preventDefault();
      e.stopPropagation();

      const pwdEl = btn.closest('.pwd');
      const password = pwdEl?.getAttribute('data-password');

      if (password) {
        pwdEl.classList.add('copying');

        const success = await copyToClipboard(password);
        if (success) {
          showToast(t('toast.passwordCopied'), 'success');
          btn.classList.add('copied');
          // Update aria-label for screen readers
          const originalLabel = btn.getAttribute('aria-label') || t('common.copy') || 'Copy';
          btn.setAttribute('aria-label', t('toast.passwordCopied') || 'Copied to clipboard');
          // WCAG recommends minimum 3 seconds for status messages
          setTimeout(() => {
            btn.classList.remove('copied');
            btn.setAttribute('aria-label', originalLabel);
          }, 3000);
        } else {
          showToast(t('toast.copyFailed'), 'error');
        }

        setTimeout(() => {
          pwdEl.classList.remove('copying');
        }, 600);
      }
    }, { signal: eventController.signal });
  });
}

/**
 * Bind breach check button click events
 */
function bindBreachCheckButtons() {
  const breachButtons = document.querySelectorAll('.breach-check-btn');

  breachButtons.forEach(btn => {
    btn.addEventListener('click', async (e) => {
      e.preventDefault();
      e.stopPropagation();

      const password = btn.getAttribute('data-password');
      if (!password) return;

      // Get the status element in the same card
      const card = btn.closest('.pwd');
      const statusEl = card?.querySelector('.breach-status');
      if (!statusEl) return;

      // Show loading state with ARIA attributes for accessibility
      btn.classList.add('checking');
      btn.disabled = true;
      btn.setAttribute('aria-busy', 'true');
      btn.setAttribute('aria-label', t('breach.checking') || 'Checking if password was breached...');
      statusEl.hidden = false;
      statusEl.setAttribute('aria-live', 'polite'); // Set aria-live when visible for proper announcements
      statusEl.className = 'breach-status loading';
      statusEl.innerHTML = `<span class="breach-spinner" role="status" aria-label="Loading"></span> ${t('breach.checkingShort')}`;

      try {
        const result = await checkPasswordBreach(password);

        if (result.error) {
          statusEl.className = 'breach-status error';
          statusEl.innerHTML = `<span class="breach-icon">‚ö†Ô∏è</span> ${t('breach.error', { error: result.error })}`;
          showToast(t('breach.error', { error: result.error }), 'error');
        } else if (result.breached) {
          const severity = getBreachSeverity(result.count);
          const countText = formatBreachCount(result.count);
          statusEl.className = `breach-status ${severity}`;
          statusEl.innerHTML = `<span class="breach-icon">üö®</span> ${countText}`;
          showToast(t('breach.passwordBreached', { count: countText }), 'error', 5000);
        } else {
          statusEl.className = 'breach-status safe';
          statusEl.innerHTML = `<span class="breach-icon">‚úÖ</span> ${t('breach.notCompromised')}`;
          showToast(t('toast.passwordNotBreached'), 'success');
        }
      } catch (err) {
        statusEl.className = 'breach-status error';
        statusEl.innerHTML = `<span class="breach-icon">‚ö†Ô∏è</span> ${t('breach.connectionError')}`;
        showToast(t('breach.connectionError'), 'error');
        safeLog(`Breach check error: ${err.message}`);
      } finally {
        btn.classList.remove('checking');
        btn.disabled = false;
        btn.removeAttribute('aria-busy');
        btn.setAttribute('aria-label', t('breach.checkButton') || 'Check if password was breached');
      }
    }, { signal: eventController.signal });
  });
}

/**
 * Show context menu for password actions
 */
function showContextMenu(e, password) {
  // Remove any existing context menu
  const existing = document.querySelector('.pwd-context-menu');
  if (existing) existing.remove();

  const vaultAvailable = VaultBridge.isAvailable();

  const menu = document.createElement('div');
  menu.className = 'pwd-context-menu';
  // ARIA: menu role for accessibility
  menu.setAttribute('role', 'menu');
  menu.setAttribute('aria-label', t('contextMenu.title') || 'Password actions');
  menu.innerHTML = `
    <button class="pwd-ctx-item" data-action="copy" role="menuitem" aria-label="${t('contextMenu.copy') || 'Copy password'}">
      <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
        <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
        <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
      </svg>
      <span>${t('common.copy') || 'Copy'}</span>
    </button>
    ${vaultAvailable ? `
      <button class="pwd-ctx-item" data-action="save-vault" role="menuitem" aria-label="${t('contextMenu.saveToVault') || 'Save to vault'}">
        <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
          <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
          <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
        </svg>
        <span>${t('vault.actions.saveToVault') || 'Save to vault'}</span>
      </button>
    ` : ''}
  `;

  document.body.appendChild(menu);

  // Position menu at cursor with viewport boundary detection
  const menuRect = menu.getBoundingClientRect();
  const viewportWidth = window.innerWidth;
  const viewportHeight = window.innerHeight;
  const padding = 8; // Minimum distance from viewport edge

  let left = e.clientX;
  let top = e.clientY;

  // Prevent menu from going off right edge
  if (left + menuRect.width + padding > viewportWidth) {
    left = viewportWidth - menuRect.width - padding;
  }

  // Prevent menu from going off bottom edge
  if (top + menuRect.height + padding > viewportHeight) {
    top = viewportHeight - menuRect.height - padding;
  }

  // Prevent menu from going off left/top edge
  left = Math.max(padding, left);
  top = Math.max(padding, top);

  menu.style.left = `${left}px`;
  menu.style.top = `${top}px`;

  // Get all menu items for keyboard navigation
  const menuItems = Array.from(menu.querySelectorAll('.pwd-ctx-item'));
  let currentIndex = 0;

  // Focus first item
  if (menuItems.length > 0) {
    menuItems[0].focus();
  }

  // Execute menu action
  const executeAction = async (item) => {
    const action = item.getAttribute('data-action');

    if (action === 'copy') {
      const success = await copyToClipboard(password);
      if (success) {
        showToast(t('toast.passwordCopied'), 'success');
      } else {
        showToast(t('toast.copyFailed'), 'error');
      }
    } else if (action === 'save-vault') {
      await SaveToVaultModal.open(password);
    }

    cleanupMenu();
  };

  // Bind menu actions (click)
  menuItems.forEach(item => {
    item.addEventListener('click', () => executeAction(item));
  });

  // Cleanup function to remove all menu listeners
  const cleanupMenu = () => {
    menu.remove();
    document.removeEventListener('click', closeMenu);
    document.removeEventListener('keydown', keyHandler);
  };

  // Close on click outside
  const closeMenu = (ev) => {
    if (!menu.contains(ev.target)) {
      cleanupMenu();
    }
  };

  // Keyboard navigation handler
  const keyHandler = (ev) => {
    switch (ev.key) {
      case 'Escape':
        ev.preventDefault();
        cleanupMenu();
        break;
      case 'ArrowDown':
        ev.preventDefault();
        currentIndex = (currentIndex + 1) % menuItems.length;
        menuItems[currentIndex].focus();
        break;
      case 'ArrowUp':
        ev.preventDefault();
        currentIndex = (currentIndex - 1 + menuItems.length) % menuItems.length;
        menuItems[currentIndex].focus();
        break;
      case 'Enter':
      case ' ':
        ev.preventDefault();
        executeAction(menuItems[currentIndex]);
        break;
      case 'Tab':
        // Close menu on Tab to allow natural focus flow
        cleanupMenu();
        break;
    }
  };

  setTimeout(() => {
    document.addEventListener('click', closeMenu);
    document.addEventListener('keydown', keyHandler);
  }, 0);
}

/**
 * Cleanup all password card event listeners
 * Uses AbortController for automatic removal of all tracked listeners
 * Also clears any pending click timers
 */
function cleanupPasswordListeners() {
  // Abort all listeners registered with the current controller
  eventController.abort();

  // Create new controller for next batch of listeners
  eventController = new AbortController();

  // Clear any pending click timers
  document.querySelectorAll('.pwd').forEach(el => {
    const timer = clickTimers.get(el);
    if (timer) {
      clearTimeout(timer);
      clickTimers.delete(el);
    }
  });

  safeLog('Password card listeners cleaned up');
}

export function updateMaskDisplay(mask) {
  document.querySelectorAll('.pwd').forEach(el => {
    el.classList.toggle('masked', mask);
  });
}

export function renderEmptyState() {
  const wrap = getElement('#results-list');
  if (wrap) {
    wrap.innerHTML = sanitizeHTML(`
      <div class="empty-state">
        <div class="empty-icon">üîê</div>
        <p>${t('generator.emptyState') || 'No passwords generated yet'}</p>
        <button type="button" class="btn btn-accent empty-state-cta" id="empty-generate-btn">
          <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
            <path d="M12 3v3m0 12v3M4.22 4.22l2.12 2.12m11.32 11.32l2.12 2.12M3 12h3m12 0h3M4.22 19.78l2.12-2.12M18.36 6.34l2.12-2.12"/>
            <circle cx="12" cy="12" r="4"/>
          </svg>
          ${t('actions.generateNow') || 'Generate Now'}
        </button>
      </div>`);
    document.getElementById('empty-generate-btn')?.addEventListener('click', () => {
      document.getElementById('btn-generate')?.click();
    });
  }
}
